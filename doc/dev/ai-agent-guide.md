## 架構概觀  在前端（React + TypeScript）專案中，要同時滿足 **「Agent → Controller 動態呼叫」** 與 **「人工審核 / Toast  UI 流程」** 這兩條 flow，可將商業邏輯拆成三層：  ``` Agent (產生字串指令)             │             ▼ Invoker / SuperController ──┬──> Queue（待審核）                             └──> Controller Facade                                    └──> 具體 xxxController / Hook / Service ```  ---  ### 1. 動態呼叫 Controller ——指令模式（[Command Pattern](https://en.wikipedia.org/wiki/Command_pattern)）  | 角色             | 職責                                     | 前端實作要點                                           | | -------------- | -------------------------------------- | ------------------------------------------------ | | **Command 物件** | 封裝「要呼叫的 action + 引數」                   | `interface Command { execute(): Promise<void> }` | | **Invoker**    | 接收 Agent 文字指令 → 轉成對應 Command → 送審或直接執行 | 可用 `SuperController` 充當                          | | **Receiver**   | 真正執行商業邏輯的 xxxController / Service      | 以 `xxxController.someAction()` 形式存在              |  * 好處：    * **字串 → 物件化**：用 `Map<string, () => Command>` 將字串指令對映到 Command 產生器。   * **易於排程 / 反悔**：Command 可序列化、排進 Queue、甚至提供 `undo`。  ---  ### 2. 統一介面 ——外觀模式（[Facade Pattern](https://en.wikipedia.org/wiki/Facade_pattern)）  為避免 Agent 直接碰到太多細節，針對每個模組定義薄薄一層 `Controller Facade`（或稱 *Service Layer*）：  ```ts export interface ITaskFacade {   addTask(input: AddTaskDTO): Promise<Result>;   removeTask(id: string): Promise<Result>; } ```  * 對 Agent／UI 來說只有這個介面； * Facade 內部再依需求呼叫 hooks、state machine、API client 等具體實作。  ---  ### 3. 審核流程 & 競態控制  **中介者模式（[Mediator Pattern](https://en.wikipedia.org/wiki/Mediator_pattern)）** 可讓 `SuperController` 集中管理：  1. **Queue 佇列**：每個 Command 進來先 `queue.push(cmd)`。 2. **審核策略**：     * *直接套用*：`SuperController.execute(cmd)`。    * *Toast 流程*：`showToast({msg, onConfirm: () => execute(cmd)})`. 3. **策略模式（[Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern)）** 把「如何執行」抽成 `ApplyPolicy`，可熱插拔。  ---  ### 4. Frontend：Controller vs. Hook？  | 做法                                  | 優點                                     | 缺點                             | 適用場景               | | ----------------------------------- | -------------------------------------- | ------------------------------ | ------------------ | | **純 OO Controller (Class/Service)** | 明確 interface；易測試；可共用於 WebWorker／Server | 於 React 中須再包一層 hook 才能存取 state | **跨框架或複用性高** 的核心邏輯 | | **React Hook**                      | 直接使用 React state/context；撰寫體驗佳         | 與 UI 耦合；難在非 React 環境重用         | **僅影響 UI 層、邏輯輕量**  |  > **建議** > > * 把 *純計算／副作用* 寫成 **Service / Controller（OO or FP）**。 > * 用 **Custom Hook** 充當 *薄包裝*（例：`useTaskFacade()` 內呼叫 Controller，再同步 local state / cache）。 > * 如此 UI 可自由換成 React Native、Web Worker 也能共用同一支 Service。  ---  ### 5. Agent 使用權限：SuperController vs. Global Flag  | 作法                      | 說明                                            | | ----------------------- | --------------------------------------------- | | **SuperController（推薦）** | 集中排程、審核、重試、快照；Log 完整；日後易加 A/B Test、Rate Limit | | **Global Store Flag**   | 最快 MVP；僅能做「開 / 關」判斷；無法追蹤多指令先後關係               |  > 若未來可能同時跑 **多個 Agent** 或需 **審計 / 回溯**，使用 `SuperController` 更安全。  ---  ### 6. 保證兩條 Flow 都能成立的實作細節  1. **定義 Command 介面**     ```ts    interface AgentCommand {      type: 'ADD_TASK' | 'DELETE_TASK' | ...;      payload: unknown;      apply(policy: ApplyPolicy): Promise<void>;    }    ```  2. **SuperController**     ```ts    class SuperController {      private queue: AgentCommand[] = [];      enqueue(cmd: AgentCommand) { this.queue.push(cmd); this.process(); }      private async process() {        const cmd = this.queue.shift();        if (!cmd) return;        // 依 policy 選 direct / toast        await cmd.apply(this.policy);        this.process(); // 遞迴處理下一筆      }    }    ```  3. **Toast Policy**     ```ts    const toastPolicy: ApplyPolicy = async (cmd, execute) => {      showToast({        message: cmd.toHumanReadable(),        onConfirm: () => execute(),  // 真正下達      });    };    ```  4. **測試策略**：為每條 flow 寫 e2e + unit test（ex. Playwright + Vitest）。  ---  ## TL;DR  * **指令模式（Command Pattern）** 讓 Agent 文字指令 ↔️ Action 雙向對映，方便排程與撤銷。 * 用 **外觀模式（Facade Pattern）** 統一 controller 介面；下層可自由選擇 Hook 或 Service。 * **SuperController**（Mediator + Queue）集中審核，能同時支援 *直接套用* 與 *Toast 確認* 兩條流程。 * 對 React UI：將 Controller 封裝成 Service，Hook 只是薄轉接，降低 UI 與商業邏輯耦合。  這樣設計既不會讓前端負擔過於「純 OO」的重量，又能保留良好擴充性與測試性。祝專案開發順利！ 