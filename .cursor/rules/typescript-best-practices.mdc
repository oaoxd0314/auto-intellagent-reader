---
description: 
globs: 
alwaysApply: false
---
# TypeScript Best Practices

1. Prefer `type` aliases over `interface`, use `interface` when extending types.
2. Never use `any`, always define explicit types.
3. Prefer `const`, avoid unnecessary use of `let`.
4. Always define function return types explicitly.
5. Clearly define types for function arguments and return values.
6. Avoid magic strings or numbers, extract them into constants.
7. Leverage utility types (Partial, Pick, Omit, Record, etc.).
8. Always enable `strict` mode.
9. Use generics for reusable and flexible functions.
10. Separate type definitions from implementation for better readability.

## Type Safety

11. **Strict Null Checks** — Enable strictNullChecks to catch null/undefined errors at compile time.
12. **Discriminated Unions** — Use discriminated unions for type-safe state management and API responses.
13. **Type Guards** — Create type guard functions to safely narrow types at runtime.
14. **Assertion Functions** — Use assertion functions for runtime type validation.
15. **const Assertions** — Use `as const` for literal types and immutable data structures.

## Advanced Types

16. **Mapped Types** — Use mapped types for transforming existing types systematically.
17. **Conditional Types** — Use conditional types for complex type logic and inference.
18. **Template Literal Types** — Use template literal types for string manipulation at type level.
19. **Index Signatures** — Use index signatures carefully, prefer Record<K, V> when possible.
20. **Branded Types** — Use branded types for domain-specific type safety (e.g., UserId, Email).
